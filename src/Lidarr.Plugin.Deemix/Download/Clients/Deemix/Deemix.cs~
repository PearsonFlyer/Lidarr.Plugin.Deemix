using System.Collections.Generic;
using System.Linq;
using System.Threading;
using FluentValidation.Results;
using NLog;
using NzbDrone.Common.Disk;
using NzbDrone.Common.Extensions;
using NzbDrone.Common.Http;
using NzbDrone.Core.Configuration;
using NzbDrone.Core.Indexers;
using NzbDrone.Core.Parser.Model;
using NzbDrone.Core.RemotePathMappings;
using SocketIOClient;

namespace NzbDrone.Core.Download.Clients.Deemix
{
    public class Deemix : DownloadClientBase<DeemixSettings>
    {
        private readonly ManualResetEventSlim _itemAdded;
        private readonly ManualResetEventSlim _configReceived;

        private SocketIO _client;
        private List<DownloadClientItem> _queue;
        private DeemixConfig _config;

        private string _addedId;

        public Deemix(IConfigService configService,
                      IDiskProvider diskProvider,
                      IRemotePathMappingService remotePathMappingService,
                      Logger logger)
            : base(configService, diskProvider, remotePathMappingService, logger)
        {
            _queue = new List<DownloadClientItem>();
            _itemAdded = new ManualResetEventSlim(false);
            _configReceived = new ManualResetEventSlim(false);
        }

        ~Deemix() => _logger.Info("Destroying Deemix class");

        public override DownloadProtocol Protocol => DownloadProtocol.Deezer;

        public override string Name => "Deemix";

        public override IEnumerable<DownloadClientItem> GetItems()
        {
            Initialize(false);

            return _queue;
        }

        public override void RemoveItem(string downloadId, bool deleteData)
        {
            Initialize(false);

            if (deleteData)
            {
                DeleteItemData(downloadId);
            }

            _client.EmitAsync("removeFromQueue", downloadId).GetAwaiter().GetResult();
        }

        public override string Download(RemoteAlbum remoteAlbum)
        {
            Initialize(false);

            var release = remoteAlbum.Release;

            int bitrate;

            if (release.Codec == "FLAC")
            {
                bitrate = 9;
            }
            else if (release.Container == "320")
            {
                bitrate = 3;
            }
            else
            {
                bitrate = 1;
            }

            _itemAdded.Reset();

            _client.EmitAsync("addToQueue", new
            {
                url = release.DownloadUrl,
                bitrate
            }).GetAwaiter().GetResult();

            _itemAdded.Wait();

            return _addedId;
        }

        public override DownloadClientInfo GetStatus()
        {
            Initialize(false);

            return new DownloadClientInfo
            {
                IsLocalhost = Settings.Host == "127.0.0.1" || Settings.Host == "localhost",
                OutputRootFolders = new List<OsPath> { _remotePathMappingService.RemapRemoteToLocal(Settings.Host, new OsPath(_config.DownloadLocation)) }
            };
        }

        protected override void Test(List<ValidationFailure> failures)
        {
            failures.AddIfNotNull(TestSettings());
        }

        private ValidationFailure TestSettings()
        {
            Initialize(true);

            // TODO: validate settings are sensible - album folder, single folder
            return null;
        }

        private void Initialize(bool reconnect)
        {
            if (Settings != null &&
                (reconnect || _client == null || _client.Disconnected || !_client.Connected))
            {
                _configReceived.Reset();
                _logger.Trace("reset received event");
                _queue = new List<DownloadClientItem>();

                var url = HttpRequestBuilder.BuildBaseUrl(Settings.UseSsl, Settings.Host, Settings.Port, Settings.UrlBase);

                _client = new SocketIO(url);

                _client.On("init_settings", OnInitSettings);
                _client.On("updateSettings", OnUpdateSettings);
                _client.On("init_downloadQueue", OnInitQueue);
                _client.On("addedToQueue", OnAddedToQueue);
                _client.On("updateQueue", OnUpdateQueue);

                _logger.Trace("Connecting to deemix");
                _client.ConnectAsync().GetAwaiter().GetResult();
                _logger.Trace("waiting for config");

                var gotConfig = _configReceived.Wait(5000);
                _logger.Trace($"got event {gotConfig}");
                if (!gotConfig)
                {
                    throw new DownloadClientUnavailableException("Unable to connect to Deemix");
                }
            }
        }

        private void OnInitSettings(SocketIOResponse response)
        {
            _logger.Trace("got settings");
            _config = response.GetValue<DeemixConfig>();
            _logger.Trace($"Download path: {_config.DownloadLocation}");
            _configReceived.Set();
        }

        private void OnUpdateSettings(SocketIOResponse response)
        {
            _logger.Trace("got settings update");
            _config = response.GetValue<DeemixConfig>(0);
        }

        private void OnInitQueue(SocketIOResponse response)
        {
            _logger.Trace("got queue");
            var dq = response.GetValue<DeemixQueue>();

            var items = dq.QueueList.Values.ToList();
            _logger.Trace($"sent {items.Count} items");

            _queue = items.Select(x => ToDownloadClientItem(x)).ToList();
            _logger.Trace($"queue length {_queue.Count}");
            _logger.Trace(_queue.ConcatToString(x => x.Title, "\n"));
        }

        private void OnUpdateQueue(SocketIOResponse response)
        {
            _logger.Trace("Got update queue");
            var item = response.GetValue<DeemixQueueUpdate>();

            var queueItem = _queue.Single(x => x.DownloadId == item.Uuid);

            if (item.Progress.HasValue)
            {
                queueItem.RemainingSize = (1 - (item.Progress.Value / 100)) * queueItem.TotalSize;
                if (item.Progress.Value == 100)
                {
                    queueItem.Status = DownloadItemStatus.Completed;
                }
            }

            if (item.Path != null)
            {
                queueItem.OutputPath = _remotePathMappingService.RemapRemoteToLocal(Settings.Host, new OsPath(item.Path));
            }
        }

        private void OnAddedToQueue(SocketIOResponse response)
        {
            _logger.Trace("Got added to queue");
            var item = response.GetValue<DeemixQueueItem>();

            _addedId = item.Uuid;
            _itemAdded.Set();

            _queue.Add(ToDownloadClientItem(item));
        }

        private DownloadClientItem ToDownloadClientItem(DeemixQueueItem x)
        {
            return new DownloadClientItem
            {
                DownloadClient = Definition.Name,
                DownloadId = x.Uuid,
                Title = $"{x.Artist} - {x.Title} [WEB] {GetFormat(x)}",
                TotalSize = x.Size * 100,
                RemainingSize = (100 - x.Progress) * x.Size,
                OutputPath = _remotePathMappingService.RemapRemoteToLocal(Settings.Host, new OsPath(x.Path)),
                Status = GetItemStatus(x),
                CanMoveFiles = true,
                CanBeRemoved = true
            };
        }

        private static string GetFormat(DeemixQueueItem item)
        {
            switch (item.Bitrate)
            {
                case "9":
                    return "[FLAC]";
                case "3":
                    return "[MP3 320]";
                case "1":
                    return "[MP3 128]";
                default:
                    return "";
            }
        }

        private static DownloadItemStatus GetItemStatus(DeemixQueueItem item)
        {
            if (item.Failed)
            {
                return DownloadItemStatus.Failed;
            }

            if (item.Progress == 0)
            {
                return DownloadItemStatus.Queued;
            }

            if (item.Progress < 100)
            {
                return DownloadItemStatus.Downloading;
            }

            return DownloadItemStatus.Completed;
        }
    }
}
